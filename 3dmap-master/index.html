<html>
	<head>
		<title>City Visualizer</title>
		<link type="text/css" rel="stylesheet" href="css/jquery.dropdown.css" />
		<link rel="stylesheet" type="text/css" href="css/style.css">

		

		<script src='js/d3graphs/d3.min.js'></script>
		<script src="js/jquery/jquery.js"></script>
		<script src="js/jquery/jquery.dropdown.js"></script>
		<script src="js/kmlTojson/togeojson.js"></script>
		<script src="js/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/utm-converter/src/converter.js"></script>
		<script src='js/d3graphs/infobox.js'></script>
		<script src='js/renderstats/stats.min.js'></script>
		<script src='js/tween/tween.js'></script>
		<script src='js/WSClient/wsClient.js'></script>
		<script src='js/models/modelsCreator.js'></script>
		<script src='js/models/ThreeCSG.js'></script>
		<script src='js/eventVisualisation/dataVisualisation.js'></script>
		<script src="js/fonts/helvetiker_regular.typeface.js"></script>

	</head>
	<body>

		<div id="infoBox">
	        1234

	    </div>
	    <div class="spinner-holder">
		    <div class="spinner">
		  		<div class="double-bounce1"></div>
		  		<div class="double-bounce2"></div>
		  		
			</div>
			<div class="spinner-text">LOADING</div>
			<div class="spinner-text" id='infoText'>waiting for city choosing</div>
		</div>

		<div id='holder'></div>

		<input type="button" data-jq-dropdown="#jq-dropdown-1" value="Choose city" id='cityChooser'>
		<div id="jq-dropdown-1" class="jq-dropdown jq-dropdown-tip dropdown-city">
		    <ul class="jq-dropdown-menu">
		        <li><a id='8k' name="Aarhus City" href="#1">Aarhus</a></li>
		        <li class="jq-dropdown-divider"></li>
		        <li><a id='cph' name="Copenhagen City" href="#2">Copenhagen</a></li>
		        <li class="jq-dropdown-divider"></li>
		        <li><a id='odense' name="Odense City" href="#3">Odense</a></li>
			<li class="jq-dropdown-divider"></li>
			<li><a id='ry' name="Ry City" href="#4">Ry</a></li> 
		    </ul>
		</div>
		<input type="button" value="add event" id='eventAdd'>

		<input type="button" data-jq-dropdown="#jq-dropdown-2" value="Choose data source" id='dataSourceChooser'>
		<div id="jq-dropdown-2" class="jq-dropdown jq-dropdown-tip jq-dropdown-anchor-right dropdown-data">
		    <ul class="jq-dropdown-menu">
		    	<li><input type="checkbox" name="datasource" value="PublicParking">Public Parking</li>
		    	<li class="jq-dropdown-divider"></li>
		    	<li><input type="checkbox" name="datasource" value="TrafficJam">Traffic Jam</li>
		    	<li class="jq-dropdown-divider"></li>
		    	<li><input type="checkbox" name="datasource" value="AarhusPollution">Aarhus Pollution</li>
		    	<li class="jq-dropdown-divider"></li>
		    	<li><input type="checkbox" name="datasource" value="AarhusNoiseLevel">Aarhus Noise</li>
		    </ul>
		</div>
	
		<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {
				
				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				
			}

		</script>

	
		<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

			}
		</script>


	
		<script>
			"use strict";
			//Set this to true to see coloring of buildings based on their geometry
			var debugGridSort = true;

			var buildingUrl = "";
			var roadUrl = "";
			var treeUrl = "";
			var waterUrl = "";

		    var buildingObjects={};		    
		    
		    var renderer=null;
		    var renderAnimationId = null;
		    var scene = new THREE.Scene();
		    var camera=null;
		    var initCameraPosition = null;
			var controls= null;
			var raycaster = null;
            var mouse =  null;
			var plane = null;

			var planeX = 10000;
			var planeY = 10000;
			var fCenterX, fCenterY;
			var minX = 10000000;
			var minY = 10000000;
			var maxX = -100000.0;
			var maxY = -100000.0;
			var wgsMinX, wgsMinY, wgsMaxX, wgsMaxY;


			var cityName = "";

			var noOfBuildings = null;
			var noOfBuildingGeoSlice = 30;

			var originalBuildingColor = 0x00ffff;
			
			
			var SHADOW_MAP_WIDTH = 1024, SHADOW_MAP_HEIGHT = 1024;
		    
			//mapping used to make sure that building height do not reach infinity
			//TODO: needs to be fitted with correct numbers
			var maxEnergyLevel = 10;
			var minEnergyLevel = 0.1;
			var maxScale = 10;
			var minScale = 0.5;

			var rendererStats = new Stats();

			Number.prototype.map = function (in_min, in_max, out_min, out_max) {
 				 return (this - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
			}

			var chosenCityId = null;

			$(function(){
				//start setting up the basics before a anything else happens
				setup();
				
				addMenuHandler();

			});


			function addMenuHandler(){


				$("#eventAdd").on('click',function(e){
					addTestEvent();
				});
				
				//handler for city select
				$(".dropdown-city > ul > li > a").on('click', function(e){

					//do nothing if same city is selected again
					if(chosenCityId!==null & chosenCityId===this.id){
						return;
					}

					chosenCityId = this.id;
					showSpinner(true);

					//set name on button
					cityName = this.name;
					$("#cityChooser").val(cityName);

					//clear scene if previously populated
					if(renderAnimationId!=null){
						cancelAnimationFrame(renderAnimationId);
					}

					for(var i = scene.children.length-1; i>=0; i--){
						var name = scene.children[i].name;
						if(!name.startsWith("sky") && !name.startsWith("spotlight") && !name.startsWith("hemilight")){

							scene.remove(scene.children[i]);	
						}
					}
					//remove any animation tweens in memory
					TWEEN.removeAll();
					//reset plane size to acommodate new models
					resetPlaneSize();

					e.preventDefault();
					populateMap(this.id);
					document.title = this.name;


				});



				//handler for data source select
				$(".dropdown-data > ul > li > input").on('click',function(e){
					updateDatasources(this.value, wgsMinX, wgsMinY, wgsMaxX, wgsMaxY);
				});

				//add key handler to reset camera view
				$(document).keydown(function(e) {
					if(e.keyCode===82){//'r' pressed
						if(camera){
							camera.position.x=initCameraPosition.x;
							camera.position.y=initCameraPosition.y;
							camera.position.z=initCameraPosition.z;
							camera.lookAt(new THREE.Vector3(0,0,0));
						}
					}
        			
    			});
			}
			
			

		    function setup()
			{	

			    //set renderbox for development information - remove all this for production
			    
				rendererStats.setMode( 0 ); // 0: fps, 1: ms, 2: mb
			    rendererStats.domElement.style.position   = 'absolute'
				rendererStats.domElement.style.left  = '0px'
				rendererStats.domElement.style.bottom    = '0px'
				//document.body.appendChild( rendererStats.domElement );
				$("#holder").append(rendererStats.domElement);
				
				//end stats
		        
                camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 5, 10000 );
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();
				mouse.x = -1;
				mouse.y = 1;
				
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.setClearColor(0xdddddd);
				renderer.shadowMapEnabled = true;
				renderer.shadowMapType = THREE.PCFSoftShadowMap;
                //document.body.appendChild( renderer.domElement );
                $("#holder").append(renderer.domElement);

                addMouseHandling();

                camera.position.z = 965;
                camera.position.x = 1435;
                camera.position.y = 1415;
				if(!initCameraPosition){
					initCameraPosition = {x:camera.position.x, y:camera.position.y, z:camera.position.z};
				}
				controls = new THREE.OrbitControls( camera, renderer.domElement );
				
				controls.enableDamping = true;
				controls.dampingFactor = 0.25;
				controls.enableZoom = true;
            
            
                // add spotlight for the shadows
                var spotLight = new THREE.SpotLight(0xffffff);
                spotLight.name = "spotlight";
                //var spotLight = new THREE.SpotLight(0xffffff, 0.9, 100000, Math.PI/2, 10, 1);
                spotLight.position.set(-0.75*planeX, 2500, 500);
                spotLight.castShadow = true;
				//spotLight.shadowCameraVisible = true;
				spotLight.shadowCameraNear = planeX/2.5;
				spotLight.shadowCameraFar = 1.5*planeX;
				spotLight.shadowCameraFov = 50;
				spotLight.shadowBias = 0.00001;
				spotLight.shadowMapWidth = SHADOW_MAP_WIDTH/2;
				spotLight.shadowMapHeight = SHADOW_MAP_HEIGHT/2;
                scene.add(spotLight);
				
				
				var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.2);
				hemiLight.name="hemilight";
				hemiLight.color.setHSL( 0.6, 1, 0.6 );
				hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
				hemiLight.position.set( 0, 500, 0 );
				scene.add( hemiLight );
				
				
                
                         
				console.log(new Date()+": End setup/start render");
				
				
				
				// SKYDOME

				var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
				var uniforms = {
					topColor: 	 { type: "c", value: new THREE.Color( 0x0077ff ) },
					bottomColor: { type: "c", value: new THREE.Color( 0xffffff ) },
					offset:		 { type: "f", value: 33 },
					exponent:	 { type: "f", value: 0.6 }
				};
				uniforms.topColor.value.copy( hemiLight.color );

				var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
				var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );
				var sky = new THREE.Mesh( skyGeo, skyMat );
				sky.name = "sky";

				sky.matrixAutoUpdate = false;
				sky.updateMatrix();

				scene.add( sky );

			
				
				
		    }

		    ///////////////////////////////////////////////////////////////
			// Helper methods for setting up the scene with different cities
			///////////////////////////////////////////////////////////////


			function resetPlaneSize(){
				minY = minX = 10000000;
				maxY = maxX = -100000.0;
			}


		    function setPlane(){
		    	var planeGeo =  new THREE.PlaneBufferGeometry(planeX, planeY,32, 32 );// new THREE.PlaneGeometry(2000,2000);
                var planeMat = new THREE.MeshLambertMaterial("rgb(128, 128, 128)");
                plane = new THREE.Mesh(planeGeo, planeMat);
 				
                // rotate it to correct position
                plane.rotation.x = -Math.PI/2;
				plane.castShadow = false;
				plane.receiveShadow = true;
				plane.name = "ground";

				plane.matrixAutoUpdate = false;
				plane.updateMatrix();

				//calculate bounding box for limiting camera position
				plane.geometry.computeBoundingBox();

                scene.add(plane);
                
				render();
		    }


		    function addMeshes(meshes, prefix){
		    	prefix += "-";
		    	var shadowBool = false;
		    	if(prefix.indexOf("buildings")>-1){

		    		shadowBool = true;
		    	}

		    	//console.log("adding "+ prefix.substring(0,prefix.length-1)+" to scene: "+meshes.length)
                for(var k=0; k<meshes.length;k++){
                	var mesh = meshes[k];
                	mesh.name = prefix+k;
                	mesh.castShadow = shadowBool;
					mesh.receiveShadow = shadowBool;
                	scene.add(mesh);
                }
		    }

		    
		    ///////////////////////////////////////////////////////////////
			// Helper methods for testing the height of the buildings
			///////////////////////////////////////////////////////////////

		    function setLevels(){
		    	
		    	var level = Math.random()*10+0.1;
		    	var index = Math.round(Math.random()*Object.keys(buildingObjects).length);
		    	
		    	changeBuilding(level, index, false);	
		    	
		    }


			///////////////////////////////////////////////////////////////
			// Rendering function for three.js
			///////////////////////////////////////////////////////////////

		    var cs = 0;
			function render()
			{

				renderAnimationId = requestAnimationFrame( render );
				TWEEN.update();		

				if(cs%100==0){

					//console.log(camera.position);	
					//console.log(scene.children);
					cs=0;
				}
				cs++;
				
				//makes sure camera does not go beyond x-axis of plane
				if(camera.position.x<plane.geometry.boundingBox.min.x){
					camera.position.x=plane.geometry.boundingBox.min.x;
				}else if(camera.position.x>plane.geometry.boundingBox.max.x){
					camera.position.x=plane.geometry.boundingBox.max.x;
				}

				//makes sure camera does not go beyond y-axis of plane
				if(camera.position.z<plane.geometry.boundingBox.min.y){
					camera.position.z=plane.geometry.boundingBox.min.y;
				}else if(camera.position.z>plane.geometry.boundingBox.max.y){
					camera.position.z=plane.geometry.boundingBox.max.y;
				} 
				

				//makes sure that camera can not go below z=0
				if(camera.position.y<0.5){
					camera.position.y=0.5;
					var pov = new THREE.Vector3(0-camera.position.x, 0-camera.position.y,0-camera.position.z);
					camera.lookAt(pov);

				}else if(camera.position.y>2200){
					camera.position.y=2200;
					var pov = new THREE.Vector3(0-camera.position.x, 0-camera.position.y,0-camera.position.z);
					camera.lookAt(pov);
				}
				
				/*
				scene.updateMatrixWorld();
				scene.traverse(function(obj){
					if(obj instanceof THREE.LOD){
						obj.update(camera);
					}
				});
				*/
				renderer.render(scene, camera);
				rendererStats.update(renderer);
			};




			///////////////////////////////////////////////////////////////
			// Mouse interaction with scene
			///////////////////////////////////////////////////////////////

		    var selectedObject=null;
            function addMouseHandling(){

            	$(document).mousemove(function(event) {
            		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	             	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;		
            	});
            	
            	$(document).dblclick(function(event) {

            		
            		if($("#infoBox").is(':visible')){
            			$("#infoBox").css('visibility', 'hidden');
            		}
            		removeEventTexts();

            		
            		raycaster.setFromCamera( mouse, camera );

					// calculate objects intersecting the picking ray
	            	var intersects = raycaster.intersectObjects( scene.children );
            		for ( var i = 0; i < intersects.length; i++ ) 
					{
						//console.log(intersects[i].object);
						if(intersects[i].object.name.startsWith("buildings") && intersects[i].face.readingId !== selectedObject){
							selectedObject = intersects[i].face.readingId; // Assign new selected object							
							break;
						}else if(intersects[i].object.name.startsWith("event")){
		            		var eventId = intersects[i].object.eventId;
		            		var serverity = Math.floor(Math.random() * 3);
		            		//updateEvent(eventId, serverity);
		            		showEventText(eventId);
		            		//removeEvent(eventId);
		            		//demoEventHack();
		            		break;
						}else if(intersects[i].object.name.startsWith("text")){
							removeEventTexts();
						}
						
						selectedObject = null;
		            }

            		
		            if(selectedObject !== null && connection!==null) {
		            	//waitingForResponse = true;
						buildingEnergyConnection.send(JSON.stringify({type: "HISTORYREQ", data: {value : selectedObject}}));
						$('#infoBox').html("Now showing data for building: " + selectedObject + "\n");
		            	$("#infoBox").css('visibility', 'visible');
		            }
						
				});
				
            }





			
            

			
			
			/*****************************/
			/*                           */
			/*         Geo data          */	
			/*                           */
			/*****************************/
			
		

			function populateMap(city){
				console.log(new Date()+": start");
				buildingUrl = "data/kml/"+city+"/sortedbuildings.kml";
				//buildingUrl = "data/kml/"+city+"/buildings.kml";
				roadUrl = "data/kml/"+city+"/roads.kml";
				treeUrl = "data/kml/"+city+"/trees.kml";
				waterUrl = "data/kml/"+city+"/water.kml";

				//waterUrl = "data/kml/"+city+"/waterTest.kml";
				
				
				getBuildings();
				//for testing the all sorts
				//testRun();

			}

			function addTestEvents(){
				for(var i=0; i<300;i++){
					addTestEvent();	
				}
			}

			var id = 0;
			//solely for testing events. Can be removed when finished
			function addTestEvent(){

				//var testPos = {lat:12.566725889453012,lng:55.68321681457061};
				var testPos = {lat:10.21, lng:56.15};
				var x = Math.floor(Math.random() * planeX)-planeX/2;
				var y = Math.floor(Math.random() * planeY)-planeY/2;
				var planePos = {x:x,y:y};
				console.log("planeX: "+planeX+" planeY: "+planeY);
				console.log("planePos.x: "+planePos.x+" planePos.y: "+planePos.y);
				var type = Math.floor(Math.random() * 4);
				var types = [];
				types.push("PublicParking");
				types.push("TrafficJam");
				types.push("AarhusPollution");
				types.push("AarhusNoise");
				var type = types[Math.floor(Math.random() * 4)];

				var serverity = Math.floor(Math.random() * 3);
				showEvent(planePos, undefined ,id, type, serverity);
				

				// type: PublicParking(0), TrafficJam(1), AarhusPollution(2), AarhusNoise(3)
				// serverity: {0,1,2}
				if(id==Number.MAX_VALUE-1){
					id=0;
				}
				id++;
			}


			function testRun(){

				$.get(buildingUrl, function(kml)
				{
					
					console.log(new Date()+":got building kml");
					
					var data = toGeoJSON.kml(kml).features;
					
					calculatePlaneBounds(data);
					setPlane();

					
					//showSpinner(false);
					//addTestEvents();
					//return;
					
					//getTrees();
					
					//addTestEvents();
					//return;
					
					getTrees();
					getWater();
					getRoads();
					
					
					noOfBuildings = data.length;

					var maxLen = Math.round(data.length/noOfBuildingGeoSlice)===0?1:Math.round(data.length/noOfBuildingGeoSlice);
					createBuildingModels(data);
					showSpinner(false);
					
				});
			}


			///////////////////////////////////////////////////////////////
			// Getting building data from server
			///////////////////////////////////////////////////////////////

			function getBuildings(){

				///////////////////////////////////////////////////////////////
				// Decide if we use local dummy data or try to connect to server via WebSockets
				///////////////////////////////////////////////////////////////
				var usingServer = true;

				
				showText("retrieving building data from server for "+cityName);
				//$.get('data/kml/aarhusByMidte.kml', function(kml)
				//$.get('data/kml/test.kml', function(kml)
				$.get(buildingUrl, function(kml)
				{
					showText("Building data loaded from server..");
					
					console.log(new Date()+":got building kml");
					
					var data = toGeoJSON.kml(kml).features;
					
					calculatePlaneBounds(data);
					setPlane();

					//getWater();
					//TEST: adding tests events to screen
					
					//showSpinner(false);
					//return;
					noOfBuildings = data.length;

					var maxLen = Math.round(data.length/noOfBuildingGeoSlice)===0?1:Math.round(data.length/noOfBuildingGeoSlice);
					//
					setTimeout(function(){
						showText("Creating building models");
						setTimeout(function(){
							createBuildingModels(data);
							showText("Building models created");
							setTimeout(function(){	
								console.log(new Date()+": buildings loaded");
								//hide spinner as system is ready
								showSpinner(false);
							},50)
							getTrees();
						},50);
						getWater();
					},50);
					getRoads();

					setupSocket();
					//for testing events - can be removed when done
					//addTestEvent();
					
					/*
					//test for showing building height change;
					if(!usingServer)
						var t=setInterval(setLevels,1000/4);
					else
						setupBuildingEnergySocket(noOfBuildings);
					*/
				});
			}


			///////////////////////////////////////////////////////////////
			// Getting road data from server
			///////////////////////////////////////////////////////////////

			function getRoads(){
				//$.get('data/kml/roadtest.kml', function(kml)
				showText("Loading roads");
				//$.get('data/kml/aarhusByMidteVeje.kml', function(kml)
				$.get(roadUrl, function(kml)
				{
					console.log(new Date()+": got road kml");
					showText("Road data loaded from server");
					var data = toGeoJSON.kml(kml);
					
					createRoadModels(data.features);
					console.log(new Date()+": roads loaded");
				});
			}





			///////////////////////////////////////////////////////////////
			// Getting water data from server
			///////////////////////////////////////////////////////////////

			function getWater(){
				//check to see if tree model is available
				$.ajax({
					url:waterUrl,
					type:"HEAD",
					success:function(){
						showText("Loading water");
						$.get(waterUrl, function(kml)
						{
							console.log(new Date()+": got water kml");
							showText("Water data loaded from server");
							//console.log(kml);
							//debugger;
							var data = toGeoJSON.kml(kml);
							//console.log(data);
							//return;
							createWaterModels(data.features);
							console.log(new Date()+": water loaded");
						});
					},
					error: function(){
						console.log("no water models available - continue with just buildings and roads");
					}
				});
				
				
			}




			///////////////////////////////////////////////////////////////
			// Getting tree data from server
			///////////////////////////////////////////////////////////////

			function getTrees(){
				//check to see if tree model is available
				$.ajax({
					url:treeUrl,
					type:"HEAD",
					success:function(){
						showText("Loading trees");
						$.get(treeUrl, function(kml)
						{
							console.log(new Date()+": got tree kml");
							showText("Tree data loaded from server");

							var data = toGeoJSON.kml(kml);

							createTreesModels(data.features);
							console.log(new Date()+": trees loaded");
						});
					},
					error: function(){
						console.log("no tree models available - continue with just buildings and roads");
					}
				});
				
				
			}


			///////////////////////////////////////////////////////////////
			// Show overlay text when loading scenes
			///////////////////////////////////////////////////////////////

			function showText(text){
				$("#infoText").text(text);
				/*
				$("#infoText").val(function(index, value){
					return value+"test"+index;
				});
				*/
			}

			///////////////////////////////////////////////////////////////
			// Show spinner or scene
			///////////////////////////////////////////////////////////////
			
			function showSpinner(showSpinner){
				if(showSpinner){
					$("#holder").hide();
					$(".spinner-holder").show();
				}else{
					console.log("show scene");
					$("#holder").show();
					$(".spinner-holder").hide();
				}
			}


		</script>
	</body>
</html>
